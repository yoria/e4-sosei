# -*- coding: utf-8 -*-
"""Func3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yyqVKd_Ahzwb_TP_TLRjKTFemtNPyX1p

# JSONの実験結果のファイルを読み取り、精度を出す（まだ途中）
"""

import re # for comvert_path function

def convert_path(path):
    a = re.sub('([0-9]+)', '', path.replace('/content/drive/MyDrive/sosei/meishi/meishi_', '').replace('.txt', '')).replace('()', '').replace('（）', '')
    return a

def get_accuracy(json_path):
    """
    JSONの実験結果のファイルを読み取り、精度を出す。
    JSONファイルのデータ構造に依存している。
    """
    import csv
    import pprint
    import json

    accuracy = 0
    CSV_PATH = "/content/drive/MyDrive/sosei/カリキュラムマップ_平坦化.csv"
    seikai_c = []
    with open(CSV_PATH) as f:
        reader = csv.reader(f)
        for row in reader:
            if row[1] == 'from' and row[2] == 'to':
                continue
            seikai_c.append(row[1:3])
    #pprint.pprint(seikai_c)

    json_open = open(json_path, 'r')
    json_load = json.load(json_open)
    seikai_num = 0;
    for c in json_load:
        for sc in seikai_c:
            #print(convert_path(c[0]))
            #print(convert_path(c[1]))
            #print(sc[0])
            #print(sc[1])
            if {sc[0], sc[1]} == {convert_path(c[0]), convert_path(c[1])}:
                seikai_num += 1
                break;
    accuracy = seikai_num / len(seikai_c)
    return accuracy
        
    """
    [
        {
            's1': value,
            'a2': value,
            'similarity': value
        },
        {
            's1': value,
            'a2': value,
            'similarity': value
        },      
    ]

    """

def get_all_combinations(sa_words, sb_words):
    all_combinations = []
    for sa_word in sa_words:
        for sb_word in sb_words:
            try:
                all_combinations.append(
                    {
                        'word1': sa_word,
                        'word2': sb_word,
                        'similarity': float(w2v_model.similarity(sa_word, sb_word))
                    }
                )
            except KeyError:
                pass
    sorted_all_combinations = sorted(all_combinations, key=lambda x: x['similarity'], reverse=True)
    return sorted_all_combinations